{"file_contents":{"main.py":{"content":"import os\nimport sys\nimport subprocess\n\n# --- Auto-install required packages ---\nrequired = [\"stellar-sdk\", \"bip-utils\", \"requests\", \"mnemonic\"]\nfor pkg in required:\n    try:\n        __import__(pkg.replace(\"-\", \"_\"))\n    except ImportError:\n        print(f\"üì¶ Installing {pkg}...\")\n        subprocess.check_call([sys.executable, \"-m\", \"pip\", \"install\", pkg])\n\n# --- Imports after install ---\nimport time\nimport requests\nfrom datetime import datetime, timezone\nfrom mnemonic import Mnemonic\nfrom bip_utils import Bip39SeedGenerator, Bip39MnemonicValidator, Bip44, Bip44Coins, Bip44Changes\nfrom stellar_sdk import Keypair, Server, TransactionBuilder, Asset, Network\n\n# ---------------- CONFIG ----------------\nHORIZON_URL = \"https://api.mainnet.minepi.com\"\nSAFE_WALLET = \"MALYJFJ5SVD45FBWN2GT4IW67SEZ3IBOFSBSPUFCWV427NBNLG3PWAAAAAAAACJUHDSOY\"\nDRY_RUN = False  # Real transactions enabled\n# ----------------------------------------\n\ndef mnemonic_to_keypair(mnemonic: str):\n    \"\"\"Convert Pi mnemonic to Ed25519 keypair using Pi Network's actual derivation method\"\"\"\n    from bip_utils import Bip32Slip10Ed25519\n    import nacl.signing\n    from stellar_sdk import StrKey\n    \n    # Pi Network uses SLIP-0010 Ed25519 derivation with path m/44'/314159'/0'\n    # This is the exact method from the official Pi Network recovery tool\n    seed_bytes = Bip39SeedGenerator(mnemonic).Generate()\n    private_key_bytes = Bip32Slip10Ed25519.FromSeed(seed_bytes).DerivePath(\"m/44'/314159'/0'\").PrivateKey().Raw().ToBytes()\n    \n    # Create Ed25519 keypair for Stellar SDK\n    kp = Keypair.from_raw_ed25519_seed(private_key_bytes)\n    return kp\n\ndef get_available_balance(public_key: str) -> float:\n    \"\"\"Query Horizon account balance and calculate spendable amount\"\"\"\n    url = f\"{HORIZON_URL}/accounts/{public_key}\"\n    try:\n        resp = requests.get(url, timeout=30)\n        if resp.status_code != 200:\n            return 0.0\n        data = resp.json()\n        \n        # Get total balance\n        total_balance = 0.0\n        for bal in data.get(\"balances\", []):\n            if bal[\"asset_type\"] == \"native\":\n                total_balance = float(bal[\"balance\"])\n                break\n        \n        # Calculate base reserve requirements\n        # Base account requires 2 base reserves (1 Pi)\n        base_reserve = 0.5  # Pi Network uses 0.5 Pi base reserve\n        account_reserves = 2 * base_reserve  # 1 Pi minimum\n        \n        # Add reserves for subentries (trustlines, offers, data entries)\n        subentries = len(data.get(\"signers\", [])) - 1  # -1 because master key doesn't count\n        subentries += data.get(\"num_subentries\", 0)  # trustlines, offers, data\n        subentry_reserves = subentries * base_reserve\n        \n        total_reserves = account_reserves + subentry_reserves\n        spendable = max(0.0, total_balance - total_reserves)\n        \n        print(f\"üí∞ Total: {total_balance} Pi | Reserved: {total_reserves} Pi | Spendable: {spendable} Pi\")\n        return spendable\n        \n    except requests.exceptions.RequestException as e:\n        print(f\"‚ùå Error fetching balance: {e}\")\n        return 0.0\n\ndef get_locked_balances(public_key: str):\n    \"\"\"Query claimable balances for locked Pi\"\"\"\n    url = f\"{HORIZON_URL}/claimable_balances?claimant={public_key}\"\n    try:\n        resp = requests.get(url, timeout=30)  # Increased timeout\n        if resp.status_code != 200:\n            return []\n        data = resp.json()\n    except requests.exceptions.RequestException as e:\n        print(f\"‚ùå Error fetching locked balances: {e}\")\n        return []\n    locked = []\n    for record in data.get(\"_embedded\", {}).get(\"records\", []):\n        amt = float(record[\"amount\"])\n        unlock_time = None\n        for claimant in record.get(\"claimants\", []):\n            predicate = claimant.get(\"predicate\", {})\n            abs_before = None\n            if \"not\" in predicate and \"abs_before\" in predicate[\"not\"]:\n                abs_before = predicate[\"not\"][\"abs_before\"]\n            elif \"abs_before\" in predicate:\n                abs_before = predicate[\"abs_before\"]\n            if abs_before:\n                unlock_time = datetime.fromisoformat(abs_before.replace(\"Z\", \"+00:00\"))\n        locked.append((amt, unlock_time))\n    return locked\n\ndef forward_all(kp: Keypair, to_addr: str):\n    \"\"\"Send all available Pi to safe wallet\"\"\"\n    server = Server(horizon_url=HORIZON_URL)\n    account = server.load_account(kp.public_key)\n\n    bal = get_available_balance(kp.public_key)\n    # Now 'bal' is already the spendable amount (reserves already subtracted)\n    # Just need to leave some for transaction fees\n    transaction_fee = 0.01  # Small buffer for transaction fees\n    \n    if bal <= transaction_fee:\n        print(\"‚ö†Ô∏è No spendable funds available after accounting for reserves and fees.\")\n        return\n    \n    # Send 95% of spendable balance, keep 5% for fees\n    amt = round(bal * 0.95, 6)\n    print(f\"üöÄ Sending {amt} Pi (keeping {round(bal - amt, 6)} Pi for transaction fees)\")\n    # Pi Network uses native asset\n    # Pi Network uses its own network passphrase (from working GitHub repo)\n    PI_NETWORK_PASSPHRASE = \"Pi Network\"\n    tx = (\n        TransactionBuilder(account, PI_NETWORK_PASSPHRASE, base_fee=100000)\n        .append_payment_op(destination=to_addr, asset=Asset.native(), amount=str(amt))\n        .set_timeout(30)\n        .build()\n    )\n    tx.sign(kp)\n\n    if DRY_RUN:\n        print(\"üöß DRY_RUN active ‚Äî transaction not sent\")\n        print(\"Signed XDR:\", tx.to_xdr())\n    else:\n        resp = server.submit_transaction(tx)\n        print(\"‚úÖ Transaction broadcast:\", resp)\n\ndef main():\n    print(\"=== Pi Auto Forwarder ===\")\n    mnemonic = input(\"Enter your 24-word Pi passphrase: \").strip()\n    kp = mnemonic_to_keypair(mnemonic)\n\n    print(\"üîë Public Key:\", kp.public_key)\n    print(\"üè¶ Safe Wallet:\", SAFE_WALLET)\n\n    while True:\n        try:\n            avail = get_available_balance(kp.public_key)\n            locked = get_locked_balances(kp.public_key)\n\n            if avail > 0.01:\n                print(f\"‚ö° {avail} Pi available ‚Äî forwarding now...\")\n                forward_all(kp, SAFE_WALLET)\n\n            soonest = None\n            for amt, unlock_time in locked:\n                if unlock_time:\n                    delta = (unlock_time - datetime.now(timezone.utc)).total_seconds()\n                    if delta > 0:\n                        print(f\"üîí {amt} Pi unlocks at {unlock_time} (in {int(delta)}s)\")\n                        if soonest is None or unlock_time < soonest:\n                            soonest = unlock_time\n\n            if soonest:\n                sleep_secs = max(0, (soonest - datetime.now(timezone.utc)).total_seconds())\n                print(f\"‚è≥ Sleeping {int(sleep_secs)}s until next unlock...\")\n                time.sleep(sleep_secs + 5)\n            else:\n                print(\"‚è∏ No locked balances. Retrying in 60s...\")\n                time.sleep(60)\n\n        except Exception as e:\n            print(\"‚ùå Error:\", e)\n            time.sleep(30)\n\nif __name__ == \"__main__\":\n    main()\n","size_bytes":7096},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.12\"\ndependencies = [\n    \"bip-utils>=2.9.3\",\n    \"mnemonic>=0.21\",\n    \"requests>=2.32.5\",\n    \"stellar-sdk>=13.0.0\",\n]\n","size_bytes":241},"replit.md":{"content":"# Pi Auto Forwarder\n\n## Overview\nThis is a Python console application that automatically forwards Pi Network cryptocurrency from user wallets to a designated safe wallet. It monitors both available and locked balances, automatically forwarding available Pi while waiting for locked balances to unlock.\n\n**Current Status**: Fully configured and running in Replit environment\n\n## Recent Changes\n- **Sept 9, 2025**: Initial setup completed\n  - Installed Python dependencies (stellar-sdk, bip-utils, requests, mnemonic)\n  - Configured console workflow for continuous monitoring\n  - Set up deployment configuration for VM hosting\n  - Application is running and awaiting user input\n\n## Project Architecture\n\n### Core Components\n- **main.py**: Single-file application containing all functionality\n- **Dependencies**: Uses Pi Network's Stellar-based blockchain via stellar-sdk\n- **BIP44 Wallet**: Converts mnemonic phrases to Ed25519 keypairs\n- **Auto-installer**: Automatically installs required packages on first run\n\n### Key Features\n- **Automatic forwarding**: Sends available Pi to safe wallet\n- **Locked balance monitoring**: Tracks and waits for locked Pi to unlock\n- **Dry run mode**: Safe testing mode (DRY_RUN = True by default)\n- **Error handling**: Robust error recovery and retry logic\n\n### Configuration\n- **HORIZON_URL**: Pi Network mainnet API endpoint\n- **SAFE_WALLET**: Destination wallet address for forwarded Pi\n- **DRY_RUN**: Safety flag for testing (set to True by default)\n\n## Deployment Settings\n- **Target**: VM (continuous running required for monitoring)\n- **Command**: `python main.py`\n- **Output**: Console (interactive input required for mnemonic)\n\n## Usage Notes\n- Application requires 24-word Pi Network passphrase at startup\n- Runs continuously monitoring for available and unlocking Pi balances\n- Safe mode enabled by default - change DRY_RUN to False for live transfers\n- Designed for long-running background operation","size_bytes":1945}},"version":1}